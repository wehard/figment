#version 330 core
precision mediump float;

uniform vec4 obj_color;
uniform int obj_id;
in vec4 o_col;

layout(location = 0) out vec4 color;
layout(location = 1) out int id;

void main()
{
  color = o_col;
  id = obj_id;
}
#version 330 core

layout(location = 0) in vec4 position;

uniform mat4 model_matrix;
uniform mat4 view_matrix;
uniform mat4 proj_matrix;
uniform vec4 obj_color;

out vec4 o_col;

void main()
{
	o_col = obj_color;
	gl_Position = proj_matrix * view_matrix * model_matrix * vec4(position.xyz, 1.0);
}
#version 330 core
precision mediump float;

uniform vec4 obj_color;
uniform int obj_id;
uniform int hovered_id;
in vec4 o_col;
in vec3 v_pos;

layout(location = 0) out vec4 color;
layout(location = 1) out int id;

float simple_random(float seed)
{
    return fract(sin(seed) * 43758.5453123);
}

vec3 random_color(float seed)
{
    float r = simple_random(seed);
    float g = simple_random(seed + 1.0);
    float b = simple_random(seed + 2.0);
    
    return vec3(r, g, b);
}

void main()
{
  float edge_smooth = 0.0;
  float width = 1.0;
  float distance = 1.0 - length(v_pos);
  float inside = smoothstep(0.0, edge_smooth, distance);
  inside *= smoothstep(width + edge_smooth, width, distance);

  if (inside == 0.0)
  {
    discard;
  }

  if (obj_id == hovered_id)
  {
    color = vec4(1.0, 1.0, 1.0, 1.0);
  }
  else
  {
    color = vec4(random_color(float(obj_id + 42)), 1.0);
  }

  color.a = inside;
  id = obj_id;
}
#version 330 core

layout(location = 0) in vec4 position;

uniform mat4 model_matrix;
uniform mat4 view_matrix;
uniform mat4 proj_matrix;
uniform vec4 obj_color;

out vec4 o_col;
out vec3 v_pos;

void main()
{
	o_col = obj_color;
	v_pos = position.xyz;
	gl_Position = proj_matrix * view_matrix * model_matrix * vec4(position.xyz, 1.0);
}
#version 330 core
precision mediump float;

out vec4 col;

in vec2 f_uv;

uniform sampler2D u_Texture;

void main()
{
	col = texture(u_Texture, f_uv);
}
#version 330 core

layout (location = 0) in vec2 v_pos;
layout (location = 1) in vec2 v_uv;

uniform mat4 model_matrix;

out vec2 f_uv;

void main()
{
	gl_Position = model_matrix * vec4(v_pos.x, v_pos.y, 0.0, 1.0);
	f_uv = v_uv;
}
#version 330 core
precision mediump float;

uniform vec2 offset;
uniform vec2 pitch;
uniform float zoom;

in vec4 o_col;
out vec4 color;

bool onGridline(int distFrom, int spacing)
{
	return mod(float(distFrom), float(spacing)) == 0.0;
}

void main()
{
	// float zoom = 1.0; // uniform
	int spacingStd = int(pitch.x);
	int effGrid = int(floor((float(spacingStd) * zoom) + 0.5));

	int fragX = int(gl_FragCoord.x - 0.5)-640;
	int fragY = int(gl_FragCoord.y - 0.5)-360;
	int width = 1280; // uniform
	int height = 720; // uniform

	int xDistFrom = int(abs(float((-offset.x * float(width)) - float(fragX))));
	int yDistFrom = int(abs(float((-offset.y * float(height)) - float(fragY))));

	if (xDistFrom == 0 || yDistFrom == 0) {
		color = vec4(0.0, 0.2, 0.4, 1.0);
		return;
	}
	else if (onGridline(xDistFrom, effGrid) || onGridline(yDistFrom, effGrid))
	{
		color = o_col;
	}
	else 
	{
		discard;
	}



	// float ox = (gl_FragCoord.x) + (offset.x * 1280.0);
	// float oy = (gl_FragCoord.y) + (offset.y * 720.0);
	// if (int(mod(ox, pitch.x)) == 0 || int(mod(oy, pitch.y)) == 0)
	// {
	// 	color = o_col;
	// }
	// else
	// {
	// 	discard;
	// }
}
#version 330 core

layout(location = 0) in vec4 position;

uniform vec4 obj_color;

out vec4 o_col;

void main()
{
	o_col = obj_color;
	gl_Position = vec4(position.xyz, 1.0);
}
struct TransformData {
    model: mat4x4<f32>,
    view: mat4x4<f32>,
    proj: mat4x4<f32>
};
@binding(0) @group(0) var<uniform> transformUBO: TransformData;

struct Fragment {
    @builtin(position) Position : vec4<f32>,
    @location(0) Color : vec4<f32>,
    @location(1) Normal : vec3<f32>
};

@vertex
fn vs_main(@location(0) vertexPosition: vec3<f32>) -> Fragment {
    var output : Fragment;

    output.Position = transformUBO.proj * transformUBO.view * transformUBO.model * vec4<f32>(vertexPosition, 1.0);
    output.Color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    output.Normal = normalize(vertexPosition);

    return output;
}

@fragment
fn fs_main(@location(0) Color: vec4<f32>, @location(1) Normal: vec3<f32>) -> @location(0) vec4<f32>
{
    var light: vec3<f32> = vec3<f32>(1.0, 1.0, 0.0);
    var col: vec3<f32> = vec3<f32>(Color.r , Color.g, Color.b) * dot(Normal, light);
    return vec4<f32>(col, 1.0);
}struct CameraData {
    view: mat4x4<f32>,
    proj: mat4x4<f32>,
};

@binding(0) @group(0) var<uniform> cameraData: CameraData;

struct VertexOutput {
    @builtin(position) pos: vec4<f32>,
    @location(0) color: vec4<f32>,
    @location(1) uv: vec2<f32>,
    @location(2) @interpolate(flat) id: i32
};

@vertex
fn vs_main(@location(0) in_world_pos: vec3f, @location(1) in_local_pos: vec3f, @location(2) in_color: vec4f, @location(3) in_id: i32) -> VertexOutput {
    var output: VertexOutput;
    output.pos = cameraData.proj * cameraData.view * vec4<f32>(in_world_pos, 1.0);
    output.uv = in_local_pos.xy;
    output.color = in_color;
    output.id = in_id;
    return output;
}

struct FragmentOutput {
    @location(0) color: vec4<f32>,
    @location(1) id: i32
};

@fragment
fn fs_main(@location(0) color: vec4<f32>, @location(1) uv: vec2<f32>, @location(2)  @interpolate(flat) id: i32) -> FragmentOutput {
    var output: FragmentOutput;
    if(abs(length(uv)) > 0.5 || abs(length(uv)) < 0.4) {
        discard;
    }

    output.color = color;
    output.id = id;
    return output;
}
struct FigmentData {
    time: f32,
    id: i32,
    model: mat4x4<f32>,
};

struct Vertex
{
    position: vec3f,
    normal: vec3f,
    texCoord: vec2f,
    color: vec4f
};

// width and height constants
const width: u32 = 32;
const height: u32 = 32;

@group(0) @binding(0) var<storage,read_write> vertexBuffer: array<Vertex,1024>;
@group(0) @binding(1) var<uniform> figmentData: FigmentData;

@compute @workgroup_size(32, 1, 1)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let rowIdx = id.x / width;
    let colIdx = id.x % height;
    let x = (f32(colIdx) / f32(width - 1) - 0.5) * 10.0;
    var y = (f32(rowIdx) / f32(height - 1) - 0.5) * 10.0;
    let z = sin(x * 0.9 + figmentData.time) * 0.5 + cos(y * 0.9 + figmentData.time) * 0.5;
    var color = vec4<f32>(x * 0.1 + 0.5, y * 0.1 + 0.5, z * 0.1 + 0.5, 1.0);

    let u = f32(colIdx) / f32(width - 1);
    let v = f32(rowIdx) / f32(height - 1);
    let uv = vec2<f32>(u, v);

    let vertex = Vertex(vec3<f32>(x, y, z), vec3<f32>(0.0, 0.0, 1.0), uv, color);
    vertexBuffer[id.x] = vertex;
}

struct RenderData {
    model: mat4x4<f32>,
    view: mat4x4<f32>,
    proj: mat4x4<f32>,
    color: vec4f,
    id: i32
};

@binding(0) @group(0) var<uniform> renderData: RenderData;

@vertex
fn vs_main(@location(0) in_vertex_position: vec3f) -> @builtin(position) vec4f {
    return renderData.proj * renderData.view * renderData.model * vec4f(in_vertex_position, 1.0);
}

struct FragmentOutput {
    @location(0) color: vec4<f32>,
    @location(1) id: i32
};

@fragment
fn fs_main() -> FragmentOutput {
        var output : FragmentOutput;
        output.color = renderData.color;
        output.id = renderData.id;
        return output;
}
struct CameraData {
    view: mat4x4<f32>,
    proj: mat4x4<f32>,
};

struct FigmentData {
    time: f32,
    id: i32,
    model: mat4x4<f32>,
};

@binding(0) @group(0) var<uniform> cameraData: CameraData;
@binding(1) @group(0) var<uniform> figmentData: FigmentData;

struct VertexOutput {
    @builtin(position) pos: vec4<f32>,
    @location(0) normal: vec3<f32>,
    @location(1) uv: vec2<f32>,
    @location(2) color: vec4<f32>
};

@vertex
fn vs_main(@location(0) in_position: vec3f, @location(1) in_normal: vec3f, @location(2) in_uv: vec2f, @location(3) in_color: vec4f) -> VertexOutput {
    var output : VertexOutput;
    output.pos = cameraData.proj * cameraData.view * figmentData.model * vec4<f32>(in_position, 1.0);
    output.normal = in_normal;
    output.uv = in_uv;
    output.color = in_color;
    return output;
}

struct FragmentOutput {
    @location(0) color: vec4<f32>,
    @location(1) id: i32
};

@fragment
fn fs_main(input: VertexOutput) -> FragmentOutput {
        var output : FragmentOutput;
        output.color = vec4<f32>(input.uv, 0.0, 1.0);
        output.id = figmentData.id;
        return output;
}
struct CameraData {
    view: mat4x4<f32>,
    proj: mat4x4<f32>,
};

@binding(0) @group(0) var<uniform> cameraData: CameraData;

struct VertexOutput {
    @builtin(position) pos: vec4<f32>,
    @location(0) color: vec4<f32>,
    @location(1) uv: vec2<f32>,
    @location(2) @interpolate(flat) id: i32
};

@vertex
fn vs_main(@location(0) in_world_pos: vec3f, @location(1) in_local_pos: vec3f, @location(2) in_color: vec4f, @location(3) in_id: i32) -> VertexOutput {
    var output: VertexOutput;
    output.pos = cameraData.proj * cameraData.view * vec4<f32>(in_world_pos, 1.0);
    output.uv = in_local_pos.xy;
    output.color = in_color;
    output.id = in_id;
    return output;
}

struct FragmentOutput {
    @location(0) color: vec4<f32>,
    @location(1) id: i32
};

@fragment
fn fs_main(@location(0) color: vec4<f32>, @location(1) uv: vec2<f32>, @location(2)  @interpolate(flat) id: i32) -> FragmentOutput {
    var output: FragmentOutput;
    output.color = color;
    output.id = id;
    return output;
}
